# FUNIKI

![Screenshot (43)](https://user-images.githubusercontent.com/100124910/169733944-133325d4-1fd8-4344-a316-c148fb94def4.png)




## Giới thiệu game - FUNIKI 

- Đối với các dòng nổi tiếng trên điện thoại không thể không kể đến game Soul Knight của nhà phát hành ChillyRoom, với một lối chơi cuốn hút đòi hỏi sự phản xạ nhạy bén của người chơi để qua ải, đồ hoạ đơn giản giống các trò chơi arcade kiểu cũ. Với sự cuốn hút như vậy em - Dương Bình Minh đã làm một phiên bản sao chép của Soul Knight đó là FUNIKI, dựa trên một chế độ chơi đặc biệt khó của game, chế độ chỉ đánh boss.
- Nhân vật sẽ sử dụng súng lục để tiêu diệt quái vật, đồng thời né những đòn tấn công của quái vật bảo toàn sinh mạng để đi đến điểm cuối để giành chiến thắng.
- Nhân vật được điều khiển bằng cách nhấn các phím trên bàn phím tương ứng: 
  + Lên: w.
  + Xuống: s.
  + Trái: a.
  + Phải: d.
- Để bắn đạn sử dụng chuột trỏ theo hướng bắn và click chuột.



- Tên game: FUNIKI.

- Thể loại: Chiến thuật, hành động.

- Đồ hoạ: 2D.

- Chế độ: offline.

- Độ tuổi: trên 10 tuổi.

- Nhà phát hành: Dương Bình Minh (Window).

- Liên hệ nhà phát hành:  [Min Duong](https://www.facebook.com/profile.php?id=100070751044461)

- Giá game: miễn phí.

  

## Cách tải game

- **Bước 1: Bấm vào đường link liên kết dưới đây.**

  https://github.com/minh0010/FUNIKI_DOWLOAD

- **Bước 2: Bấm chọn mục Code.**

  ![Screenshot (45)](https://user-images.githubusercontent.com/100124910/169734049-f568dae9-5cfe-43be-9b2c-b63750602be6.png)

- **Bước 3: Tiếp tục chọn Dowload ZIP.**

  ![Screenshot (47)](https://user-images.githubusercontent.com/100124910/169734070-687dd571-48a8-40ad-9f5d-f164edd56dce.png)

  chọn vị trí lưu file rồi bấm save
  
  ![Screenshot (48)](https://user-images.githubusercontent.com/100124910/169734092-afd815da-5057-449d-85f2-7a0cc47fe74e.png)

  sau khi tải xong file thì chuyển sang bước 4.

- **Bước 4: Đến thư mục chứa file vừa tải về, nhấn chọn file rồi click chuột phải.**

  ![Screenshot (50)](https://user-images.githubusercontent.com/100124910/169734120-34732eee-ff10-41bc-a431-f4fe839a2e06.png)

  chọn Extract Here.
  
  ![Screenshot (49)](https://user-images.githubusercontent.com/100124910/169734193-d1d612a6-4803-4a49-bcd5-8a14257654bb.png)

- **Bước 5: Sau khi giải nén, ta bấm chọn vào file mới được giải nén**

  ![Screenshot (51)](https://user-images.githubusercontent.com/100124910/169734289-20f29e48-b519-4f44-b97c-f9f50f3be534.png)

  nháy chuột hai lần vào file có tên FUNIKI_GAME.exe để bắt đầu chơi

  ![Screenshot (52)](https://user-images.githubusercontent.com/100124910/169734637-88472728-aa73-43d5-a6da-75b742f9c02a.png)

  khi chạy được game màn hình hiển thị

  ![Screenshot (53)](https://user-images.githubusercontent.com/100124910/169734806-27e12d8d-5e5d-43ef-a8be-a7467b433911.png)

- **Lưu ý game hiển thị tốt nhất với màn hình có tần số quét 60Hz, để có trải nghiệm chơi tốt nhất nên thiết đặt tần số quét của màn hình là 60Hz  theo hướng dẫn sau:**

  + Bước 1: Chọn Start -> Setting hoặc Window + I để mở hộp thoại Setting.
  + Bước 2: Tại hộp thoại Setting chọn System -> Display -> Advanced display setting.
  + Bước 3: Tại mục Refresh Rate, chọn tần số 60Hz.



## Một số chức năng game

- Khi mới vào màn hình chính của game nếu người chơi muốn lựa chọn chơi game luôn hãy nhấn play.

  ![43d](https://user-images.githubusercontent.com/100124910/169734612-0c82e5ca-8da1-4f7f-8dd1-c66e8ec56434.png)




- Nhưng trước khi chơi game nên tìm hiểu cách chơi trước bằng cách nhấn vào ký hiệu dấu hỏi chấm ở góc dưới để hiển thị ra bảng hướng dẫn chơi

  ![43b](https://user-images.githubusercontent.com/100124910/169734589-0a9453b2-1387-4b13-a3b1-443dd7adfc50.png)




- Muốn tắt âm thanh game, nhấn vào ký tự nốt nhạc.

  ![43a](https://user-images.githubusercontent.com/100124910/169734567-2b78b213-632d-4a57-a8af-f26974f666ef.png)




- Để xem thành tích top 5 lần chơi hoàn thành game nhanh nhất, nhấn vào kí hiệu ba dấu gạch ngay cạnh nút mở hướng dẫn chơi.

  ![43c](https://user-images.githubusercontent.com/100124910/169734532-f4e164d7-70e4-47d5-81df-027a3bf1ed7e.png)




- Nếu muốn thoát game nhấn nút x ở góc dưới cùng bên phải.

  ![43](https://user-images.githubusercontent.com/100124910/169734693-3ab51a61-cfcc-44db-96b4-94325b5a1eb0.png)




- Ngoài ra còn có menu tạm dừng game trong lúc chơi, để bật menu tạm dừng nhấn kí hiệu hình răng cưa góc trên cùng bên phải.

  ![Screenshot (55)](https://user-images.githubusercontent.com/100124910/169734723-ad49090a-ac2f-49dd-b7e5-5dafa0aeb49b.png)




- Trong menu tạm dừng có các menu tuỳ chọn tương ứng chức năng:

  continue = tiếp tục chơi game.

  back = thoát ra màn hình chính.

  ngoài ra trong menu tạm dừng cũng có nút bật tắt âm nhạc.

  ![Screenshot (56)](https://user-images.githubusercontent.com/100124910/169734737-14854870-a2e5-4a69-a7c8-99040db98137.png)




## Một số kĩ thuật được sử dụng

- **Lớp đối tượng cơ bản (class TEXTURE) và kĩ thuật Color Key**

  - Là một lớp đối tượng cơ sở đại diện cho một đối tượng hình ảnh được hiển thị trên màn hình, sẽ có một số đối tượng được kế thừa từ TEXTURE: player, gun, bullet, ....

  - Trong lớp TEXTURE có các hàm đơn giản như:

    - load_texture_from_file(...) - thực hiện công việc tải một ảnh từ file lưu trữ đến TEXTURE.
    - loadFromRenderedText(...) - tải một xâu chữ tạo thành một TEXTURE. 
    - render_texture_on_screen(...) - hiển thị hình ảnh hiện tại lên màn hình chơi game.
    - set_display_width(...), set_display_height(...) - cài đặt hai thông số chiều rộng và chiều cao hiển thị hình ảnh trên màn hình.
    - setBlend_Mode(...), setAlpha(...) - hai hàm cần thiết để điều chỉnh độ mờ của ảnh.
    - free(...) - giải phóng dữ liệu. 

  - Kĩ thuật Color Key: trong hàm load_texture_from_file(...) ngay sau khi tải được một ảnh vào SDL_Surface trung gian thì thực hiện lệnh xoá phông nền bằng mã màu với ba chỉ số red (R), green (G), blue (B):

    	SDL_SetColorKey(SDL_Surface*, R, G, B);

  - Để thuận tiện cho lấy mã màu để xoá phông nền của ảnh em đã dùng phần mềm hỗ trợ Adobe Photoshop CS6 để thu được mã màu chính xác nhất.

  

- **Cấu trúc vector định hướng (struct Direction_Vector)** 

  - Để thuận tiện cho việc định hướng di chuyển của đạn thì đơn giản nhất là dùng vector định hướng trong không gian hai chiều. Mỗi vector sẽ có hai chỉ số a và b là toạ độ của vector trong không gian.
  - Ngoài ra trong cấu trúc còn có sự định nghĩa lại toán tử (nạp chồng toán tử) để định nghĩa các phép tính cơ bản của vector.
  - Và một hàm Get_Vector_Length(...) thực hiện tính toán và trả về độ dài của vector.

  

- **Kĩ thuật tile map**

  - Kĩ thuật tile map là kĩ thuật xây dựng bản đồ quan trọng trong lập trình game 2D, giúp người lập trình chia bản đồ của ý tưởng thành từng ô vuông nhỏ, hỗ trợ phân loại vật thể cùng và khác đặc tính để thiết lập vào các vị trí mà người lập trình chỉ định.

  - Trong kĩ thuật tile map, người lập trình dùng một file văn bản (.txt, .map, ...) để mô phỏng vị trí các ô vuông (sau khi bản đồ ý tưởng được chia) bằng một chỉ số type. Chỉ số này được phân loại bằng tính chất vật thể mà người lập trình thiết lập. Ví dụ: Đất = 0, nước = 1, đá = 2, ... .Khi hoàn thành bản đồ mô phỏng toạ độ, người lập trình sẽ truyền vào trong đoạn code của mình các chỉ số type, đồng thời khởi tạo tại đó một biến tile chứa toạ độ x, y và type để phân loại các tile khác nhau.

  - Đối với game FUNIKI em đã sử dụng một file map_level1.txt để mô phỏng vị trí các ô vuông của màn chơi 1, và các chỉ số type là các số nguyên trong khoảng từ 0 -> 7.

    ![Screenshot (58)](https://user-images.githubusercontent.com/100124910/169735001-448f00b8-3753-4a23-8bba-adbc3357658b.png)


​    

  - Mỗi chỉ số type tương ứng:

    - 0 = FLOOR_PATH (nền mặt đất).
    - 1 = FLOOR_PATH_WITH_SHADOW_PATH (nền mặt đất có thêm bóng).
    - 2 = WALL_SIDE_PATH (cạnh bên tường).
    - 3 = WALL_TOP_PATH (cạnh trên tường).
    - 4 = GATE_WAY_PATH (nền cổng).
    - 5 = GATE_WAY_WITH_SHADOW_PATH (nền cổng có thêm bóng).
    - 6 = CORNER_PATH (góc tường).
    - 7 = BLACK_PATH (vùng đen).

    

  - Để lưu hình ảnh hiển thị cho từng loại tile, em dùng một đối tượng thuộc lớp TEXTURE để lưu lại ảnh.

    ![path](https://user-images.githubusercontent.com/100124910/169735093-4a101518-6e6d-44a8-82b5-f14ab0bf7692.png)


​    

  - Trong phần code thì em đã phân tile có type = 3 là vật cản không thể đi qua tạo thành một vùng chơi game khép kín cho người chơi.

  - Kĩ thuật tile map giúp cho việc phân loại các vật thể khác nhau dễ dàng đồng thời dễ tạo dựng map dễ dàng hơn, tuy nhiên lại cần khởi tạo nhiều lần.



- **Lớp nhân vật - class REAPER** 

  - Lớp nhân vật (trong game là class REAPER) là một lớp kế thừa từ lớp TEXTURE, trong đó lưu trữ một hình ảnh của nhân vật (sprite).

    (hình ảnh nhân vật)

     ![reaper](https://user-images.githubusercontent.com/100124910/169735111-2929e2af-cc2a-48d1-b824-89f198764c33.png)


​    

  - Nhân vật được đặt tên là REAPER.

  - Nhưng nếu chỉ sử dụng mỗi một hình ảnh tĩnh cho nhân vật thì game sẽ không có sự chân thật, nên em đã áp dụng hiệu ứng animation để tạo sự sinh động và thực tế cho việc nhân vật di chuyển. 

  - Nguyên lý cơ bản: 

    Sử dụng frame_clip để lưu trữ lần lượt vị trí và kích thước của frame trong sprite nhân vật

  - Trong game, em sử dụng hai mảng frame_clip để lưu frame:

    - Reaper_Idle_Frame là mảng lưu trữ các thông số frame khi nhân vật đứng yên.
    - Reaper_Running_Frame là mảng lưu trữ các thông số frame khi nhân vật di chuyển.

  - Khi nhân vật di chuyển hay đứng im thì các frame liên tục thay thế cho nhau tạo nên hiệu ứng động của nhân vật, và các frame sẽ được thiết đặt các thông số bằng hàm Set_Reaper_Frame(...).

    

  - Xử lý nhân vật di chuyển và hiển thị nhân vật:

    - Load_Reaper_From_File(...) - tải hình ảnh vào lưu trữ trong TEXTURE.

    - Handle_Reaper(...) - hàm có chức năng xác định phím định hướng di chuyển đã được nhấn, trạng thái hiện tại của nhân vật, hướng nhìn của nhân vật, nhận biết nhân vật có bắn đạn hay không.
    - Reaper_Move(...) - hàm thực hiện di chuyển nhân vật chính theo hướng tương ứng với các phím đã nhấn ở hàm Handle_Reaper(...) đồng thời xác định nhân vật có va chạm vật chắn (tường) hay không nếu có thì nhân vật sẽ bị chặn lại.
    - Render_Reaper_On_Screen(...) - hiển thị hình ảnh của nhân vật trên màn hình dựa theo vị trí của nhân vật (đã được tính toán và có sự thay đổi thông qua hai hàm Handle_Reaper(...) và Reaper_Move(...)).
    - Set_Reaper_Camera(...) - cật nhật vị trí của camera theo sự di chuyển của nhân vật.

    

  - Trong lớp nhân vật còn có một số hàm liên quan đến khả năng tấn công của nhân vật:

    - Handle_Gun(...), Render_Gun(...) - thực hiện chức năng liên tục cật nhật hướng xoay của súng và hiển thị trên màn hình.
    - Handle_Reaper_Life(...), Render_Reaper_Blood(...) - cật nhật chỉ số máu của nhân vật và hiển thị trên màn hình.
    - Handle_Bullet_List(...) - mỗi viên đạn được lệnh tạo ra mỗi khi người chơi nhấn chuột được xác định ở hàm Handle_Reaper(...), thì đến hàm Handle_Bullet_List(...) sẽ thực hiện chức năng liên tục cật nhật vị trí của viên đạn theo hướng bắn đã được cài đặt và hiển thị viên đạn trên màn hình, và viên đạn sẽ được xoá khi va chạm một vật thể.

    

  - Một số hàm còn lại liên quan đến cài đặt chỉ số của nhân vật:

    - Set_Start_Position(...) - cài đặt vị trí đầu tiên khi vào chơi.
    - Set_Is_Reaper_Alive(...) - cài đặt nhân vật còn sống hay không.
    - Set_Use_Sound_Effect(...) - cài đặt cho nhân vật có sử dụng âm thanh khi bắn đạn hay không.

    

  - Một số hàm lấy thông tin:

    - Get_Reaper_Rect(...) - lấy thông số về vị trí hiển thị của nhân vật chính, kích thước hiển thị.
    - Get_Is_Reaper_Alive(...) - lấy thông tin về việc nhân vật còn sống hay không. 
    - Get_Reaper_Collision_Box(...) - lấy thông số SDL_Rect thường dùng để xác định xem người chơi có bị ảnh hưởng bởi chiêu thức của quái vật hay không.
    - Get_Bullet_List(...) - lấy thông tin về những viên đạn đã được tạo và hiển thị trên màn hình.

    

  - Reset_From_Start(...) - cài đặt lại thông số nhân vật giống như khi mới bắt đầu chơi, thường sẽ được sử dụng khi muốn chơi lại sau khi hết game.

    

- **Lớp đạn người chơi (class BULLET) và lớp súng (GUN_BULLET)**

  - Đây là hai lớp hỗ trợ chủ yếu cho khả năng tấn công của người chơi, trong đó lớp đạn (class BULLET) hỗ trợ xử lý đạn bắn ra từ người chơi và lớp súng (class GUN) hỗ trợ xử lý hình ảnh súng của người chơi.
  - Trước hết về lớp đạn (class BULLET):
    - Handle_Bullet(...) - thay đổi liên tục vị trí của viên đạn dựa theo vector đường đi đã được thiết đặt, đồng thời xác định xem viên đạn có gặp vật cản hay không, nếu gặp vật cản thì cài đặt đạn đang không di chuyển.
    - Render_Bullet_On_Screen(...) - hiển thị hình ảnh của viên đạn trên màn hình dựa theo vị trí hiện tại.
    - Set_start_position(...) - cài đặt vị trí bắt đầu hiển thị viên đạn.
    - Set_Vector_Move_Direction(...) - thiết đặt vector chỉ hướng của viên đạn, vector này sẽ được sử dụng trong Handle_Bullet(...) để cật nhật vị trí mới của viên đạn.
    - Set_Is_Bullet_Move(...) - cài đặt viên đạn đang chuyển động trên màn hình hay không.
    - Hàm lấy thông số của đạn: Get_Bullet_Rect(...), Get_Is_Bullet_Move(...).

  

  - Tiếp theo là lớp súng (class GUN), là một lớp kế thừa của TEXTURE:
    - Load_Gun_Texture(...) - tải và lưu trữ hình ảnh súng vào TEXTURE.
    - Update(...) - thực hiện việc tính toán góc xoay của súng theo hướng của chuột đang trỏ trên màn hình và cật nhật góc quay đó cho hiển thị trên màn hình.
    - Set_Rect(...) - cài đặt vị trí hiển thị chính của súng.
    - Get_x(...) và Get_y(...) là hai hàm lấy thông số toạ độ hiển thị x, y của súng trên màn hình.

  

- **Lớp quái vật - class JUNGLE_PIG**

  - Lớp quái vật (class JUNGLE_PIG) là một lớp xây dựng quái vật heo rừng là quái vật để người chơi tiêu diệt và hoàn thành trò chơi.

  - Là một lớp kế thừa lớp TEXTURE lưu trữ hình ảnh của quái:

    ![jungle_pig](https://user-images.githubusercontent.com/100124910/169735197-0376ce77-be50-4db5-84b3-a81ffcbbbb59.png)


​    

  - Tương tự như lớp người chơi để tạo hiệu ứng animation sử dụng mảng frame_clip để lưu trữ thông số cho frame tương ứng với trạng thái của quái:

    - Boss_Idle_Frame là mảng lưu trữ các frame cho trạng thái đứng yên cho quái.

    - Boss_Run_Frame là mảng lưu trữ các frame cho trạng thái di chuyển của quái.

    - Các thông số của hai mảng này sẽ được cật nhật khi gọi hàm Get_Reaper_Rect(...).

      

  - Xử lý di chuyển và hiển thị quái:

    - Load_Jungle_Pig_Texture(...) - tải hình ảnh của quái và lưu trữ trong TEXTURE.

    - Handle_Boss_Move(...) - cật nhật vị trí của quái khi quái di chuyển đến vị trí mới.

    - Render_Jungle_Pig(...) - hiển thị hình ảnh của quái trên màn hình.

      

  - Vì quái sẽ tự động tấn công người chơi nên có một số hàm tự động:

    - Generate_New_Position(...) - lấy một vị trí mới để quái vật di chuyển tới.
    - Load_Boss_Bullet_Fire_Toward_Player(...) - hàm tạo ra đạn bắn hướng theo vị trí của người chơi đang đứng.
    - Load_Boss_Bullet_Fire_In_12_Direction(...) - hàm tạo ra đạn bắn toả vòng tròn theo 12 hướng.
    - Load_Boss_Meteo(...) - hàm tạo ra thiên thạch rơi ngẫu nhiên trong bản đồ và bị giới hạn trong khu vực chơi.
    - Auto(...) - là một hàm tự động thực hiện việc gọi hàm Generate_New_Position(...) để tạo sự di chuyển cho boss, tự động thực hiện gọi ngẫu nhiên Load_Boss_Bullet_Fire_Toward_Player(...), Load_Boss_Bullet_Fire_In_12_Direction(...) hoặc Load_Boss_Meteo(...) để tấn công người chơi.
    - Handle_Skills(...) - liên tục cật nhật vị trí mới của chiêu thức và hiển thị các chiêu thức của quái vật trên màn hình trò chơi.

    

  - Một số hàm cài đặt thông số của quái vật:

    - Set_Jungle_Pig_Start_Position(...) - cài đặt vị trí bắt đầu của quái khi mới vào game.
    - Set_Is_Alive(...) - cài đặt trạng thái sống hay không của quái.
    - Set_Jungle_Pig_Start_To_Fight(...) - thường sẽ cần điều kiện người chơi đi vào khu vực chơi thì quái mới tấn công, hàm này sẽ dùng để cài đặt lúc nào thì quái mới tấn công, lúc nào không.

  

  - Một số hàm lấy thông số của quái vật:

    - Get_Is_Jungle_Pig_Alive(...) - lấy thông tin quái còn sống hay không.
    - Get_Jungle_Pig_Rect(...) - lấy vị trí, kích thước hiển thị của quái vật trên màn hình chơi.
    - Get_Jungle_Pig_Collision_Box(...) -tương tự như lớp người chơi thì hàm này cũng thường dùng để xác định va chạm của quái với đạn mà nhân vật tạo ra.
    - Get_Bullet_List(...) - lấy danh sách đạn mà quái bắn ra đang có trên màn hình.
    - Get_Meteo_List(...) - lấy danh sách thiên thạch mà quái tạo ra đang có trên màn hình.

    

  - Và hai hàm đặc biệt:

    - Clear_Boss(...) - xoá hết trạng thái của quái trên màn hình, thường sẽ được sử dụng khi người chơi thành công tiêu diệt quái.
    - Reset_From_Start(...) - tất cả các thiết đặt của quái trở về như lúc mới vào game, thường được sử dụng khi người chơi muốn chơi lại game.

  

- **Lớp đạn của quái vật (class BOSS_BULLET) và lớp thiên thạch (class METEO)** 

  - Là hai lớp hỗ trợ chính cho chiêu thức tấn công của quái vật, lớp đạn quái vật (class BOSS_BULLET) hỗ trợ cài đặt và hiển thị cho đạn mà quái vật bắn ra, còn lớp thiên thạch (class METEO) hỗ trợ hiển thị thiên thạch xuất hiện trên màn hình.
  - Lớp đạn của quái vật (class BOSS_BULLET):
    - Handle_Boss_Bullet(...) - cật nhật vị trí mới và xác định xem đạn hiện tại có gặp vật cản hay không, nếu gặp vật cản thì cài đặt đạn đang không di chuyển.
    - Render_Boss_Bullet_On_Screen(...) - hiển thị hình ảnh của đạn trên màn hình dựa theo vị trí hiện tại.
    - Set_start_position(...) - cài đặt vị trí bắt đầu hiển thị của đạn.
    - Set_Vector_Move_Direction(...) - cài đặt hướng bắn của đạn.
    - Set_Is_Boss_Bullet_Move(...) - cài đặt đạn có đang di chuyển hay không.
    - Set_Bullet_Move_Speed(...) - cài đặt tốc độ di chuyển của đạn.
    - Và một số hàm lấy thông tin của đạn.
  - Lớp thiên thạch (class METEO), cũng sử dụng hiệu ứng animation giống với lớp người chơi và lớp quái vật thông qua việc lưu trữ các thông số của các frame_flip trong sprite nhân vật:
    ![meteo](https://user-images.githubusercontent.com/100124910/169735459-0c47da36-abf0-4ce5-b9cc-ad29ccea1c86.png)


  - Lớp thiên thạch có một số hàm chính như:
    - Set_Boss_Meteo_Positon(...) - cài đặt vị trí rơi của thiên thạch.
    - Set_Is_Boss_Meteo_Falling(...) - cài đặt trạng thái rơi của thiên thạch.
    - Set_Boss_Limit(...) - cài đặt giới hạn rơi của thiên thạch.
    - Set_Is_Create_Lava_Pool(...) - cài đặt có khởi tạo vùng lava hay không.
    - Set_Lava_Position(...) - cài đặt vị trí hiển thị lava.
    - Set_red_x(...) - cài đặt vị trí của dấu x, là nơi đánh dấu vị trí thiên thạch sắp rơi để cảnh báo người chơi.
    - render_meteo_falling_position(...) - hiển thị vị trí dấu x trên màn hình giúp cảnh báo người chơi.
    - Set_Lava_Center(...) - căn chỉnh hai giá trị lava_center_x và lava_center_y là hai toạ độ tâm của vùng lava.
    - handle_meteo(...) - liên tục cật nhật vị trí mới và xác định xem thiên thạch đã đến giới hạn chưa, nếu đã đến giới hạn thì thiết lập thiên thạch không còn rơi.
    - render_meteo(...) - hiển thị thiên thạch dựa trên vị trí hiện tại.
    - delay_lava_pool(...) - cài đặt hiển thị vùng lava chỉ xuất hiện trên màn hình trong một khoảng thời gian nhất định.
    - delay_damage(...) - tính toán thời gian cứ mỗi giây người chơi dứng trong khu vực lava thì sẽ gây sát thương cho người chơi.
    - Và một số hàm lấy giá trị, thông số khác.

  

- **Lớp máu (class BLOOD)**

  - Là một lớp hỗ trợ hiển thị thanh máu của người chơi và quái vật, sử dụng hai đối tượng TEXTURE để lần lượt hiển thị hình ảnh thanh máu và lượng máu còn lại.
  - Các hàm chức năng chính:
    - Load_Blood_Texture(...) - tải hình ảnh và lưu trữ trong các đối tượng TEXTURE.
    - Render_Blood_Bar(...) - hiển thị thanh máu trên màn hình.
    - Set_Start_Blood(...) - cài đặt máu gốc khi bắt đầu game.
    - Set_Display_Blood(...) -  cài đặt máu được hiển thị trên màn hình.
    - Set_Remain_Blood_Clip(...), Set_Display_Blood_Bar_Clip(...), Set_Remain_Blood_On_Screen(...) và Set_Display_Blood_Bar_On_Screen(...) là các hàm thực hiện chức năng cài đặt các frame_clip.
    - Reduce_Blood_By_Damage(...) - giảm máu hiện tại dựa trên thông số sát thương đầu vào.
    - Reset_Blood(...) - cài máu trở về thông số gốc đã được cài trước đó (cả máu gốc và máu hiển thị trên màn hình).
    - Get_Current_Blood(...) - lấy thông số máu hiện tại của đối tượng (người chơi hoặc quái vật).



- **Lớp nút bấm (class BUTTON) và lớp menu (class MENU)**

  - Lớp nút bấm (class BUTTON) là một lớp hỗ trợ tạo ra các nút chức năng chính của menu game, xác định trạng thái sử dụng nút bấm còn lớp menu (class MENU) sẽ thực hiện tổng hợp các nút, chuyển đổi việc sử dụng các nút trong các màn hình hiện hành.

  - Trước hết về lớp nút bấm (class BUTTON), là một lớp kế thừa từ lớp TEXTURE với các hàm chính:

    - Để tạo hiệu ứng khác nhau khi trỏ chuột vào nút, nhấn nút, di chuyển chuột ra ngoài nút sử dụng frame_clip để lưu các thông số của frame cho việc hiển thị. Và để cài đặt các thông số đó, sử dụng các hàm set_button_clip_out(...), set_button_clip_over(...), set_button_clip_down(...) và set_button_clip_up(...).
    - set_in_use_button(...) - cài đặt nút hiện tại có được sử dụng hay không.
    - set_is_button_click(...) - cài đặt nút đang được bấm hay không.
    - set_button_rect(...) - cài đặt vị trí và kích thước hiển thị của nút bấm trên màn hình.
    - load_button(...) - tải và lưu trữ hình ảnh vào TEXTURE.
    - handle_button(...) - xác định vị trí giữa con trỏ chuột và nút bấm để thực hiện thay đổi sử dụng các frame_clip.
    - render_button(...) - hiển thị hình ảnh của nút bấm trên màn hình.
    - Và hai hàm get_is_button_click(...) và get_is_button_in_use(...) dùng để lấy thông số xác định việc nút có được bấm hay không và nút có được sử dụng hay không

  - Lớp menu (class MENU):

    - Là một lớp chứa tổng hợp tất cả các nút bấm, hình nền và âm thanh của game. Các đối tượng này sẽ được tải và lưu trữ từ file tài nguyên và được cài đặt sẵn trong các hàm cài đặt:

      - Load_All_Button_And_Background_Display(...) - tải tài nguyên hình ảnh của các nút và màn hình nền.

      - load_sound_effect_and_music(...) - tải tài nguyên âm thanh.

        

    - Việc sử dụng các nút sẽ dựa trên trạng thái màn hình hiện tại (screen_status), đồng thời mỗi màn hình sẽ sử dụng một hình nền riêng tương ứng

      **START_SCREEN**

      ![start_screen](https://user-images.githubusercontent.com/100124910/169735599-0ac38b8d-59ff-4f59-a014-6777ee0bf6f7.png)


​      

      **PLAY_SCREEN**
    
      không có nền riêng, hình ảnh hiển thị sẽ là tile map, nhân vật người chơi và quái vật tương tác trên màn hình


​      

      **PAUSE_SCREEN**
    
      ![pause_screen](https://user-images.githubusercontent.com/100124910/169735619-ae264169-273f-4bf8-a4b5-364eecc580a0.png)


​      

      **SCREEN_AFTER_LOSE**
    
      ![screen_after_lose](https://user-images.githubusercontent.com/100124910/169735639-7c028c00-a6ce-4db8-9ab6-65363af6a708.png)


​      

      **SCREEN_AFTER_WIN**
    
      ![screen_after_win](https://user-images.githubusercontent.com/100124910/169735652-5ace0af7-7969-40ff-9766-5babad6ff3dd.png)


​      

      **HELP_SCREEN**
    
      ![help_menu](https://user-images.githubusercontent.com/100124910/169735685-267115fd-c34a-45a6-b50d-d543b9e32c9c.png)


​      

      **RESULTS_SCREEN**
    
      ![results_background](https://user-images.githubusercontent.com/100124910/169735704-81597d55-2f2b-4f79-96ac-a1051b8dc97d.png)


​      

      **OPEN_RANK_TABLE**
    
      ![ranking_background](https://user-images.githubusercontent.com/100124910/169735722-53baa26d-b000-4fe5-9d27-da78a14264b2.png)


​      

    - Đối với mỗi màn hình hiển thị sẽ tương ứng một hàm cài đặt các nút được sử dụng riêng
    
      - Set_Start_Screen(...) - cài đặt sử dụng các nút có trong START_SCREEN.
    
      - Set_PLaying_Screen(...) - cài đặt sử dụng các nút có trong PLAY_SCREEN.
    
      - Set_Pause_Screen(...) - cài đặt sử dụng các nút có trong PAUSE_SCREEN.
    
      - Set_Screen_After_Lose(...) - cài đặt sử dụng các nút có trong SCREEN_AFTER_LOSE.
    
      - Set_Screen_After_Win(...) - cài đặt sử dụng các nút có trong SCREEN_AFTER_WIN.
    
      - Set_Help_Screen(...) - cài đặt sử dụng các nút có trong HELP_SCREEN.
    
      - Set_Results_Screen(...) - cài đặt sử dụng các nút có trong RESULTS_SCREEN.
    
      - Set_Open_Ranking_Screen(...) - cài đặt sử dụng các nút có trong OPEN_RANK_TABLE.


​        

    - Trong toàn bộ menu có tất cả các nút chức năng sau:
    
      - start_play_button - nút bắt đầu chơi game.
      - quit_button - nút thoát game.
      - mini_menu_button - nút mở menu tạm dừng khi đang chơi.
      - continue_button - sau khi mở menu tạm dừng, nếu muốn chơi tiếp sử dụng nút này để chơi tiếp.
      - back_to_start_button - sau khi mở menu tạm dừng, nếu muốn quay lại màn hình bắt đầu sử dụng nút này để quay về màn hình bắt đầu.
      - next_button - sau khi xem xong kết quả mỗi lần chơi game (cả thắng và thua) bấm next để tiếp tục.
      - yes_button - sau khi thắng hoặc thua nếu muốn chơi tiếp nhấn nút yes_button, thực hiện cài đặt lại các thông số của người chơi và quái vật, và đưa về màn hình chơi game.
      - no_button - sau khi thắng hoặc thua nếu không muốn chơi tiếp nhấn nút no_button sẽ đưa về màn hình bắt đầu.
      - turn_on_off_sound_button - tắt bật âm lượng.
      - turn_on_help_screen_button - bật bảng hướng dẫn.
      - exit_help_screen_button -  thoát bảng hướng dẫn.
      - rank_button - tắt bật bảng xếp hạng thời gian hoàn thành game nhanh nhất.


​      

    - Để thực hiện việc chuyển đổi màn hình ta có hàm Handle_All_Button(...):
    
      -  Nhận diện nút được bấm và chuyển đổi màn hình hiện hành.
      -  Thay đổi cài đặt các nút tương ứng được sử dụng trong màn hình hiện hành.
      -  Tạo âm mỗi khi có một nút được bấm.


​      

    - Chức năng hiển thị hình ảnh của các nút do hàm Render_Menu_Button(...) thực hiện, song song với đó là hiển thị hình nền do hàm Render_Background(...) thực hiện.


​      

    - Đối với game thì âm nhạc là một thứ không thể thiếu, để phụ trách chức năng phát nhạc khi chơi hoặc tắt âm theo lệnh tắt sử dụng hàm Handle_sound(...).

  


- **Lớp chuột (class MOUSE)**

  - Để cho bớt sự nhàm chán với chuột mặc định của Window, trong game cần có sự thay đổi về hiển thị của chuột, và để thực hiện chức năng đó lớp chuột (class MOUSE) là cần thiết.

  - Lớp chuột (class MOUSE) là một lớp kế thừa của lớp TEXTURE, sử dụng hàm Load_Mouse_Texture(..) để tải hình ảnh từ file và liên tục Render_Mouse(...) ngay tại vị trí của con trỏ chuột mặc định.

    ![mouse](C:\Users\Admin\Pictures\Screenshots\mouse.png

    

  - Tuy nhiên khi thực hiện tải hình ảnh và hiển thị bình thường thì trên màn hình hiển thị của game vẫn sẽ nhìn thấy chuột mặc định của Window, để tắt hiển thị chuột mặc định cần thêm lệnh 

    SDL_ShowCursor(false).

  - Lệnh này giúp ẩn hiển thị con trỏ chuột mặc định trong màn hình hiển thị game.

  

- **Ngoài ra còn có hàm chung**

  - check_collision(...) - kiểm tra hai vật thể có va chạm nhau không, hàm này ứng dụng rất nhiều trong việc kiểm tra va chạm của người chơi với quái vật, người chơi với một ô trong tile map, người chơi với đạn của quái vật, quái vật với đạn của người chơi, ....

  - touch_wall(...) - là hàm kiểm tra xem người chơi có chạm tường hay không, đạn có chạm tường hay không ... tuy nhiên thực chất hàm này là tổng hợp của nhiều hàm check_collision(...) kiểm tra một vật thể với tường chắn.

    

## Kết luận

- Kết luận chung: Việc hoàn thành trò chơi FUNIKI đã giúp em cải thiện được nhiều kĩ năng lập trình, tìm kiếm thông tin, giải quyết các vấn đề và đọc hiểu tài liệu tiếng anh, đồng thời còn giúp em hiểu được khái quát cấu trúc và các hoạt động của một chương trình, làm nền tảng cho em sau này trong việc sử dụng các game engine như Unity, Cocos....

- Hướng phát triển:

  - Hiện tại game chỉ có một màn chơi, một loại quái nên chắc chắn hướng phát triển tiếp theo của em sẽ là tạo thêm nhiều màn chơi đồng thời mở rộng bản đồ chơi, tạo thêm nhiều loại quái vật khác nhau.

  - Ngoài ra còn có thể cho thêm một vài vật phẩm chức năng, thay đổi loại súng, ....

- Sau khi hoàn thành bài tập em rút ra được rất nhiều bài học trong lập trình trong đó có những bài học rất quan trọng:

  - Nên thực hiện chia tách file để quản lý dữ liệu: đây là điều mà ngay từ lúc bắt đầu làm game em đã không thực hiện, khiến cho việc viết code và quản lý các đối tượng rất khó khăn, đồng thời xác định lỗi cũng gặp nhiều trở ngại, nhưng khi chia tách việc quản lý các đối tượng theo các file nhất định thì những trở ngại đó cũng mất đi thay vào đó việc viết code sẽ được trơn tru, quản lý các đối tượng cũng như tìm lỗi dễ dàng, hạn chế lượng thời gian cần bỏ ra để hoàn thành cài đặt, tổ chức một đối tượng, một lớp nhất định.

  - Mỗi khi làm xong một đoạn hàm chức năng nào đó nên xem xét lại và chỉnh sửa sao cho hàm được tối ưu nhất: tuy sau mỗi lần viết hàm em đều có chỉnh sửa, thay đổi để code có sự tối ưu, nhưng theo nhận xét của bản thân em thì vẫn có một số hàm chưa đạt đến mức tối ưu nhất, thế nên trong quá trình game chạy vẫn còn một số lỗi chưa tìm được giải pháp giải quyết hoàn toàn và đây là điều đáng lưu ý.

    

### Lời cảm ơn

Em xin gửi lời cảm ơn chân thành nhất đối với các thầy phụ trách giảng dạy môn lập trình nâng cao

- Thầy Trần Quốc Long.
- Thầy Đỗ Minh Khá.
- Thầy Nguyễn Việt Anh.

vì đã giúp em hoàn thành bài tập này.